# 前言

# 1. 数据结构分类

## 1.1 逻辑结构：
### 1.1.1集合结构
线性结构（1对1）
树形结构（1对多）
图形结构（多对多）

### 1.1.2物理结构
1.顺序存储结构 （地址连续） 查找效率高，增删慢
2.链式存储结构（指针）查找效率低，增删快

# 2.算法
1.花最少的时间
2.占最少的内存

# 3.算法分析
## 3.1时间复杂度分析
1.常数忽略不计
2.最高次项的常数因子可以忽略不计
3.只看最高次项，后面的忽略不计
4.n^3>n^2>nlog(n)>n>log(n)>1

### 3.1.1 大O记法
1.用常数1取代运行时间中的所有加法常数
2.修改运行次数中，保留最高阶项
3.如果最高阶项存在，且常数因子不为1，则去除这个项相乘的常数

用最坏情况
## 3.2 空间复杂度分析
# 正片

# 1. 排序
## 1.1 冒泡排序
每次把最大的或最小的移到一边
``` java
public class BubbleSort {
    public static void sort(int[] array){
        int temp;
        for(int i=0;i<array.length;i++){
            for(int j=0;j< array.length-i-1;j++){
                if(array[j]>array[j+1]){
                    temp=array[j+1];
                    array[j+1]=array[j];
                    array[j]=temp;
                }
            }
        }
    }
```
个人感悟：
最简单的排序
### 时间复杂度分析
O（n^2）

## 1.2 选择排序
第一次从待排序的数据中选择最小的（最大的），存放在序列的起始位置，再从未排序的数据中选择最小的（最大的），放到未排序的起始位置。
``` java
public class SelectionSort {
    public static void sort(int[] array){
        int min;
        int min_index=0;
        int temp;
        for(int j=0;j< array.length-1;j++) {
            min=array[j];
            min_index=j;
            for (int i = j+1; i < array.length; i++) {
                if (array[i] < min) {
                    min = array[i];
                    min_index = i;
                }
            }
            temp = array[j];
            array[j] = min;
            array[min_index] = temp;
        }
    }

```
个人感悟：
比较简单
### 时间复杂度分析
O(n^2)

## 1.3 插入排序
1.把元素分为两组，已排序和未排序
2.找到未排序的第一个元素，向已排序的组进行插入
3.倒序遍历已排序元素，依次与待插入元素比较，直到找到一个元素小于等于待插入的元素，那么就把元素插到这个位置，其他元素向后移一位

``` java
public static void Insertionsort(int[] array){
        int temp;
    for(int i=1;i< array.length;i++){
        for(int j=i;j>0;j--){
            if(array[j]<array[j-1]){
                temp=array[j-1];
                array[j-1]=array[j];
                array[j]=temp;
            }
            else{
                break;
            }
        }
    }
    }

```
个人感悟：
比较简单

### 时间复杂度分析
O(n^2)

## 1.4 希尔排序
1.选定一个增长量h，按增长量h为数据分组的依据，对数据进行分组
2.对分好组的没一个组数据完成插入排序
3.减小增长量，最小减为1，重复第二步操作

``` java
public static void Shellsort(int[] array){
    int temp;
    int h;
    while(h< array.length/2)
    {
        h=2*h+1;
    } //设定增长量
    while(h>=1){
        for(int i=h;i<array.length;i++){
            for(int j=i;j>=h;j=j-h){
                if(array[j]<array[j-h]){
                    temp=array[j];
                    array[j]=array[j-h];
                    array[j-h]=temp;
                }
                else{
                    break;
                }
            }
        }
    h=h/2; //增长量减小
    }
    }
```
个人感悟：
{4,1,2,3,5,9,8,6,5,7},h=2时，一开始没做出来，老想着先生成索引为0 2 4 6 8     1 3 5 7 9的序列，再从左往右依次应用插入排序，实际上需要插入排序的元素就是索引大于等于h的元素，两个序列可以一个一个元素分开考虑，不一定要按序列来一起弄。
### 时间复杂度分析
事后估算法：
比插入排序快很多

## 1.5 归并排序
1.尽可能把原数据拆分为两个元素相等的子组，并对每个子组拆分，直到每个子组的元素个数为1
2.将相邻的两个子组合并成一个有序大组；
3.不断重读步骤2，直到形成一个组
```java
public class MergeSort {

    public static void Sort(int[] array){
        int[] assit=new int[array.length];//创建辅助列表
        int lo=0;
        int hi=array.length-1;
        sort(array,lo,hi,assit);

    }
    public static void sort(int[] array,int lo,int hi,int[]assit){
        if(hi<=lo){
            return;
        }else{
            //分成两个组
            int mid=lo+(hi-lo)/2;
            sort(array,lo,mid,assit);  //分
            sort(array,mid+1,hi,assit);
            Merge(array,lo,mid,hi,assit);//并
        }
    }


    public static void Merge(int[] array,int lo,int mid,int hi,int[] assit){
    //定义三个指针
        int p1=lo;
        int p2=mid+1;
        int i=lo;

    //遍历，移动指针，找出小的那个,放到辅助数组
    while(p1<=mid&&p2<=hi) {
        if(array[p1]<array[p2]){
            assit[i++]=array[p1++];
        }
        else{
            assit[i++]=array[p2++];
        }

    }
        //如果p1没走完
        while(p1<=mid){
            assit[i++]=array[p1++];
        }

        //如果p2没走完
        while(p2<=hi){
            assit[i++]=array[p2++];
        }
        //辅助数组拷贝到原数组
        for(int index=lo;index<=hi;index++){
            array[index]=assit[index];
        }


    }
```
个人感悟：
代码好长，首先开头创建一个辅助列表，先分后并，并的时候搞三个指针,牺牲空间复杂度换取时间复杂度
### 时间复杂度分析
O(nlogn）

## 1.6快速排序
1.设定一个分界值，将数据分为左右两个部分
2.将大于等于分界值的数据放到分界值的右边，小于等于分界值的数放到分界值左边
3.左右两边的分别排序
4.重复上述过程

``` java
    public static void sort(int[] array){
        int lo=0;
        int hi= array.length-1;
        Sort(array,lo,hi);
    }

    public static void Sort(int[] array,int lo,int hi){
        if(lo>=hi){
            return;
        }
        else{
            //先分组 分别让左子组、右子组有序
            int partition=Partition(array,lo,hi); //分界值的索引
            Sort(array,lo,partition-1);
            Sort(array,partition+1,hi);
        }
    }


    public static int Partition(int[] array,int lo,int hi){
        int left;
        int right;
        int temp;
        while(true){
            left=lo+1;
            right=hi;
            for(;right>=lo;right--){
                if(array[right]<array[lo]){ //从右向左遍历，找到比分界值更小的数 索引保存在right中
                    break;
                }
            }
            for(;left<=hi;left++){            /从左向右遍历，找到比分界值更大的数 索引保存在left中
                if(array[left]>array[lo]){
                    break;
                }
                else if(left==right){     //如果左右指针指向同一个数，那么这个数与分界值交换
                    temp=array[lo];
                    array[lo]=array[left];
                    array[left]=temp;
                    break;
                }
            }

            if(left==right){
                break;       //左右索引指向同一个数，循环终止
            }
            else{
                temp=array[left];
                array[left]=array[right]; //交换左右指针指向的数
                array[right]=temp;
            }
        }
        return left; //返回交换后分界值的索引
    }

```
个人感悟：
核心部分Partition自己写的，前面递归的框架还是不太熟练，但是理解起来比归并排序容易多了
###  快速排序一个函数版本
```java
public static void quicksort(int[] array,int low,int high){ //这个版本需要传入low和high
        if(low>high){
            return;
        }
        int lo=low;
        int hi=high;

        while(true) {
            while (lo < hi) {
                if (array[hi] < array[low]) {
                    break;
                }
                hi--; //找到比基准小的
            }
            while (lo < hi) {
                lo++;
                if (array[lo] >array[low]) {
                    break;
                } //找到比基准大的

                if(hi==lo){
                    int temp=array[low];
                    array[low]=array[lo];
                    array[lo]=temp;
                    break;
                }
            }
            if(hi==lo){
                break;
            }
            int temp = array[lo];
            array[lo] = array[hi];
            array[hi] = temp;
            lo=low;
            hi=high;
        }
        quicksort(array,lo+1,high);
        quicksort(array,low,lo-1);
    }
```

### 时间复杂度分析
最优情况：O（nlogn）
最坏情况：O（n^2）
## 1.7排序稳定性
对同一组数据进行多次排序，如果有相同的数据，顺序不改变，比如A1 B D C A2 ，排序完成是
A1 A2 B C D ，而不是A2 A1 B C D。
稳定的：冒泡排序；插入排序；归并排序
不稳定的：选择排序；希尔排序；快速排序

# 下面可公开的情报
如何实现自己的迭代器：
首先实现Iterable接口，进而实现接口中的Iterator iterator()方法，该方法返回接口Iterator，Iterator接口中封装了next,hasnext等方法。
hasnext（）判断是否还有元素可以遍历
next（）返回下一个元素

# 2.线性表
## 2.1顺序表
```java
public class SequenceList<T> implements Iterable{  //实现Iterable接口
    //初始化数组
    private T[] eles;
    //记录当前顺序表中元素的个数
    private int N;
    public SequenceList(int capacity){
        //初始化数据
        this.eles=(T[])new Object[capacity];
        //初始化元素
        this.N=0;
    }
    //将一个线性表置为空表
    public void clear(){
        this.N=0;
    }
    //判断当前线性表是否为空表
    public boolean isEmpty(){
        return N==0;
    }
    //获取线性表的长度
    public int length(){
        return N;
    }
    //获取指定位置元素
    public T get(int i){
        return eles[i];
    }
    //向线性表中添加元素t
    public void insert(T t){  //扩容 如果已经满，容量乘以2
        if(N==eles.length){
            resie(2*eles.length);
        }
        eles[N++]=t;
    }
    //在i索引处插入元素t
    public void insert(int i,T t){
        if(N==eles.length){
            resie(2*eles.length); //扩容 如果已经满，容量乘以2
        }
        //先往后移
        for(int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        eles[i]=t;
        N++;
    }
    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        T record=eles[i];
        for(int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        N--;
        if(N<eles.length/4){   //如果元素不满长度的1/4，缩容一半
            resie(eles.length/2);
        }
        return record;
    }
    //查找t元素的第一个位置
    public int indexOf(T t){
       for(int i=0;i<N;i++){
           if(eles[i].equals(t)){
               return i;
           }
       }
       return -1;
    }
    //扩容和缩容
    public void resie(int newsize){
        //定义临时数组，指向原数组
        T[] temp=eles; //保存原数组数据
        //创建新数组
        eles=(T[])new Object[newsize];//新的空数组，
        //拷贝
        for(int i=0;i<N;i++){
            eles[i]=temp[i];
        }

    }


    //遍历
    @Override
    public Iterator<T> iterator() {   //进而实现Iterator iterator()方法，该方法返回接口Iterator
        return new SIterator();
    }
    private class SIterator implements Iterator{
        private int cusor;
        public SIterator(){
            this.cusor=0;
        }
        @Override
        public boolean hasNext() {
            return cusor<N;
        }

        @Override
        public Object next() {
            return eles[cusor++];
        }
    }

}
```
## 2.2链表
### 2.2.1 单向链表
```java
public class Linklist<T> implements Iterable<T>{
    //头结点
    private Node head;
    //记录链表长度
    private int N;
    //结点类
    private class Node{
        //存储数据
        T item;
        //存储下一个结点
        Node next;
        public Node(T item,Node next){
            this.item=item;
            this.next=next;
        }
    }
    public Linklist(){
        //初始化头结点
        this.head = new Node(null,null);
        //初始化元素个数
        this.N=0;

    }

    //清空链表
    public void clear(){
        head.next=null;
        N=0;
    }
    //获取链表长度
    public int length(){
        return N;
    }
    //判断链表是否为空
    public boolean isEmpty(){
        return N==0;
    }
    //获取指定位置i的元素
    public T get(int i){
        //通过循环开始往后找，依次找i次
        Node n=head.next;
        for(int index=0;index<i;index++){ //头 0 1 2 3
            n=n.next;
        }
        return n.item;
    }
    //向链表中添加t
    public void insert(T t){
        //找到最后一个结点
        Node n=head;
        while(n.next!=null){
            n=n.next;
        }
        //创建新结点
        Node n_new=new Node(t,null);
        //最后一个元素指向新节点
        n.next=n_new;
        //个数加一
        N++;

    }
    //向链表中指定位置i添加元素t
    public void insert(int i,T t){
        //找到i之前一个结点
        Node pre=head;
        for(int index=0;index<i;index++){ //头 0 1 2 3
            pre=pre.next;
        }
        //找到i位置的结点
        Node n_i=pre.next;
        //创建新结点，指向之前i位置的结点
        Node n_new=new Node(t,n_i);
        //i前一个元素指向新节点
        pre.next=n_new;

        //个数加一
        N++;
    }
    //删除指定i处元素并返回该元素
    public T remove(int i){
        Node pre=head;
        //找到i之前的那个元素
        for(int index=0;index<i;i++){ //头 0 1 2 3
            pre=pre.next;
        }
        Node current=pre.next;
        Node post=current.next;
        pre.next=post;
        N--;
        return current.item;
    }
    //查找元素t在链表中第一次出现的位置
    public int indexOf(T t){
        Node n=head;
        for(int index=0;n.next!=null;index++){  //头 0 1 2
            n=n.next;
            if(n.item.equals(t)){
                return index;
            }
        }
        return -1;

    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
    }
    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }
}
```
个人感悟：
比排序简单，代码有瑕疵，清空的功能自欺欺人
### 2.2.2 双向链表
```java
public class BioLinkList<T> implements Iterable{
    private Node head;
    private Node last;
    private int N;
    public class Node{
        T item;
        Node next;
        Node pre;
        public Node(T item,Node pre,Node next){
            //存储数据
            this.item=item;
            //指向上一个结点
            this.pre=pre;
            //指向下一个结点
            this.next=next;
        }
    }
    public BioLinkList(){
        //初始化头结点和尾结点
        head = new Node(null,null,null);
        last = null;
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear(){
        head.next=null;
        last=null;
        N=0;
    }
    //获取链表长度
    public int length(){
        return N;
    }
    //判断链表是否为空
    public boolean isEmpty(){
        return N==0;
    }
    //获取链表第一个元素
    public T getFirst(){ //头 0 1 （head不存储数据
        if(isEmpty()){
            return null;
        }
        else{
            return head.next.item;
        }
    }
    //获取链表最后一个元素
    public T getLast(){
        if(isEmpty()){
            return null;
        }
        else{
            return last.item;
        }
    }


    //获取指定位置i的元素
    public T get(int i){
        //通过循环开始往后找，依次找i次
        Node n=head.next;
        for(int index=0;index<i;index++){
            n=n.next;
        }
        return n.item;
    }
    //向链表中添加t
    public void insert(T t){ //接到末尾
        //如果链表为空
       if(isEmpty()){
           Node newNode=new Node(t,head,null);
           last=newNode;
           head.next=last;
       }
       else{
           Node oldLast=last; 
           Node newNode=new Node(t,oldLast,null);
           oldLast.next=newNode;
           last=newNode;
       }
       N++;

    }
    //向链表中指定位置i添加元素t
    public void insert(int i,T t){
        //找到i之前一个结点
        Node pre=head;
        for(int index=0;index<i;index++){ //头 0 1 2 3
            pre=pre.next;
        }
        //找到i位置的结点
        Node current=pre.next;
        //创建新结点，指向之前i位置的结点
        Node newNode=new Node(t,pre,current);
        current.pre=newNode;
        pre.next=newNode;
        //个数加一
        N++;
    }
    //删除指定i处元素并返回该元素
    public T remove(int i){
        Node pre=head;
        //找到i之前的那个元素
        for(int index=0;index<i;i++){ //头 0 1 2 3
            pre=pre.next;
        }
        //当前的结点
        Node current=pre.next;
        //之后的结点
        Node post=current.next;
        pre.next=post;
        post.pre=pre;
        N--;
        return current.item;
    }
    //查找元素t在链表中第一次出现的位置
    public int indexOf(T t){
        Node n=head;
        for(int index=0;n.next!=null;index++){  //头 0 1 2
            n=n.next;
            if(n.item.equals(t)){
                return index;
            }
        }
        return -1;

    }

    @Override
    public Iterator<T> iterator() {
        return new LIterator();
    }
    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }
}
```
### 2.2.3 链表反转
```java
//用来反转整个链表
    public void reverse(){ //head 0 1 2 3
        //是否为空链表
       if(isEmpty()){
           return;
       }
       else{
           reverse(head.next);
       }
    }
    //指定反转某个结点
    public Node reverse(Node curr){
       if(curr.next==null){ //如果是尾结点
           head.next=curr;
           return curr;
       }
       //返回值作为当前结点的上一个结点
       else{
           Node pre=reverse(curr.next); //不是尾结点就递归
           pre.next=curr;
           curr.next=null;
           return curr;
       }
    }
```
个人感悟：
使用递归的思想，一直调到尾结点,如果是尾极点，将头结点指向它；如果不是尾结点，递归。
### 2.2.4 快慢指针

定义两个指针，移动速度一快一慢，来制造差值，快指针的移动步长是慢指针的两倍

#### 2.2.4.1中间值问题
快指针移动到尾结点，由于移动速度是慢指针的两倍，慢指针此时刚好在中间结点处
```java
 public T getMid(Node first){
        //定义两个指针
        Node fast=first;  //指向第一个结点
        Node slow=first;
        //遍历
        while(fast.next!=null&&fast!=null){
            fast=fast.next.next;
            slow=slow.next;
        }
        //快指针指向尾结点，结束

        //慢指针指向的为中间值
        return slow.item;
    }
```
#### 2.2.4.2 单向链表是否有环问题
如果有环，快指针会追上慢指针
```java
public boolean isCircle(Node first){
        Node fast=first;
        Node slow=first;
        while(fast.next!=null&&fast!=null){
            fast=fast.next.next;
            slow=slow.next;
            //如果fast和slow指向同一个结点
            if(fast.equals(slow)){
                return true;
            }
        }
        return false;
    }
```
#### 2.2.4.3 有环链表入口问题
当快慢指针相遇后，再设置一个新指针指向第一个结点，慢指针和新指针相遇的地方就是环入口
```java
public Node getEntrance(Node first){
        Node fast=first;
        Node slow=first;
        Node slow_2=null;
        while(fast.next!=null&&fast!=null){
            fast=fast.next.next;
            slow=slow.next;
            //如果fast和slow指向同一个结点,说明有环
            if(fast.equals(slow)){
                slow_2=first;
                continue;
            }
            //slow_2开始行动
            if(slow_2!=null){
                slow_2=slow_2.next;
                if(slow.equals(slow_2)){ //两个慢指针相遇，循环退出
                    break;
                }
            }
            
        }
        return slow_2;//返回入口处
    }
```
个人感悟：
涉及数论，不想去证明，会用就好

### 2.2.5 循环链表

最后一个结点指向首结点
### 2.2.6 约瑟夫问题
围成一个圈，报到3的人退出圈，由下一个人报1，周而复始，求出最后一个人退出的编号
```java
public class Joseph {
    public static void main(String[] args) {
    //构建循环链表
        Node<Integer> first=null;//头结点
        Node<Integer> pre=null; //前一个结点
        for(int i=1;i<42;i++){
            if(i==1){
                first=new Node<>(i,null);
                pre=first;
                continue;
            }

            Node<Integer> newNode = new Node<>(i, null);
            pre.next=newNode;
            pre=newNode;
            if(i==41){
                pre.next=first;
            }


        }
        //计数器模拟报数
        int count=0;
        //遍历
        //默认每次从首结点开始
        Node<Integer> n=first;
        Node<Integer> before=null;
        while(n.next!=n){
            //模拟报数
            count++;
            //判断是不是3
            if(count==3){
                //如果是3，删除结点，打印当前结点，重置count，后移
                before.next=n.next;
                System.out.println(n.item);
                count=0;
                n=n.next;
            }
            else{
                before=n;
                n=n.next;
            }

        }
        System.out.println(n.item);
    }
        private static class Node<T> {
            //存储数据
            T item;
            //存储下一个结点
            Node next;

            public Node(T item, Node next) {
                this.item = item;
                this.next = next;
            }
        }

}
```
## 2.3栈
基于先进后出的数据结构，只能在一端进行插入和删除操作的特殊线性表。
数据进入到栈的过程作为压栈，数据从栈出去的动作为弹栈

使用链表，压入元素接在头节点后面，弹出也是头节点后面的元素

```java
public class Stack<T> implements Iterable{
    //记录首结点
    private Node head;
    //栈中元素的个数
    private int N;
    private class Node{
        public T item;
        public Node next;
        private Node(T item,Node next){
            this.item=item;
            this.next=next;
        }
    }
    public Stack(){
        this.head=new Node(null,null);
        this.N=0;
    }
    //判断栈中的元素是否为0
    public boolean isEmpty(){
        return N==0;
    }
    //获取栈中元素的个数
    public int size(){
        return N;
    }
    //把t元素压入栈
    public void push(T t){
        Node old_first=head.next; //获取头结点下一个结点
        if(old_first==null){   //如果此节点为空
            Node n = new Node(t,null); //新结点直接接头结点后面
            head.next=n;
            N++;
        }
        else{
            Node n = new Node(t,old_first); //如果不为空，原先第一个结点接新节点后面
            head.next=n;
            N++;
        }
    }
    //弹出栈顶元素
    public T pop(){
        Node old_first=head.next;
        if(old_first==null){
            return null;
        }
        else{
            Node post=old_first.next; //弹出第一个结点
            head.next=post;
            N--;

        }
        return old_first.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    public class SIterator implements Iterator{
        private Node n;
        public SIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }

}
```
### 2.3.1括号匹配问题
遍历字符串，遇到一个左括号，压入栈中，遇到一个右括号，弹出栈，看最后栈中有没有元素
```java
public class BracketMatch {
    public static void main(String[] args) {
        String str="(shit(nnd)())";
        boolean match=isMatch(str);
        System.out.println(match);

    }
    public static boolean isMatch(String str){
        //创建栈对象
        Stack<String> stack = new Stack<>();
        //从左往右遍历
        for(int i=0;i<str.length();i++){
            //是否为左括号
            String curr=str.charAt(i)+"";
            if(curr.equals("(")){
                stack.push(curr);
            }
            else if(curr.equals(")")){ //是否为右括号，弹出一个最括号，判断是否为null
                String result=stack.pop();
                if(result.equals(null)){
                    return false;
                }
            }
        }
        if(stack.isEmpty()){
            return true;
        }
        else{
            return false;
        }

    }
}
```
个人感悟：
这个方法好der，为了用栈而用栈，而且没有考虑右括号在最左边的情况

### 2.3.2逆波兰表达式求值问题（后缀表达式）
运算符放在相关操作数之后
```java
public class ReversePolishNotationTest {
    public static void main(String[] args) {
        //中缀表达式 3*（17-15）+18/6       逆波兰表达式： 3 17 15-*    18 6 / +
        String[] notation = {"3", "17", "15", "-", "*", "18", "6", "/", "+"};
        int result = calculate(notation);
        System.out.println(result);
    }

    public static int calculate(String[] notation) {
        //创建栈对象
        Stack<Integer> stack = new Stack<>();
        //从左往右遍历
        for (int i = 0; i < notation.length; i++) {
            String curr = notation[i];
            //是否为操作符
            if (curr.equals("+") || curr.equals("-") || curr.equals("*") || curr.equals("/")) {
                Integer op1 = stack.pop();// 取出操作符前两个数
                Integer op2 = stack.pop();
                int result = 0;
                if (curr.equals("+")) {
                    result = op1 + op2;
                    stack.push(result);
                } else if (curr.equals("-")) {
                    result = op2 - op1;
                    stack.push(result);
                } else if (curr.equals("*")) {
                    result = op1 * op2;
                    stack.push(result);
                } else if(curr.equals("/")) {
                    result = op2 / op1;
                    stack.push(result);
                };
            }
            else{                 //如果不是操作符，压入栈中，注意string要变换为Int
                    stack.push(Integer.parseInt(curr));
            }
        }
        int final_result = stack.pop();
        return final_result;
    }
}
```

## 2.4 队列
先进先出的数据结构，只能从一端插入，在另一端进行删除的特殊线性表。

使用链表，插入元素插在尾结点，弹出元素是弹出头节点下一个

```java
public class Queue<T> implements Iterable<T>{
    private Node head; //头结点
    private Node last;//尾结点
    private int N;
    public class Node{
        public T item;
        public Node next;
        public Node(T item,Node next){
            this.item=item;
            this.next=next;
        }
    }
    public Queue(){
        this.head=new Node(null,null);
        this.last=null;
        this.N=0;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return N==0;
    }
    //获取队列中元素个数
    public int size(){
        return N;
    }
    //从队列中拿出一个元素
    public T dequeue(){
        if(isEmpty()){
            return null;
        }
        else{
            Node n=head.next; //将头结点的下一个拿走
            Node oldsecond=n.next;
            head.next=oldsecond;
            N--;
            if(isEmpty()){
                last=null;
            }
            return n.item;
        }

    }
    //从队列中插入一个元素
    public void enqueue(T t){   //插在尾结点之后
        Node n = new Node(t,null);
        if(last==null){
            last=n;
            head.next=last;
            N++;
        }
        else{
            Node oldlast=last;
            last=n;
            oldlast.next=last;
            N++;
        }
    }

    @Override
    public Iterator<T> iterator() {
        return new QIterator();
    }
    private class QIterator implements Iterator{
        public Node n;
        public QIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }
}
```
# 3.符号表
## 3.1 普通符号表
将一个键和一个值联系起来，用键来查找值，键需要有唯一性，类似python中的字典，没有顺序
```java
public class Symboltable<Key,Value>{
    private Node head;
    private int N;
    public class Node{
        public Key key;
        public Value value;
        public Node next;
        public Node(Key key,Value value,Node next){
            this.key=key;
            this.value=value;
            this.next=next;
        }
    }
    public Symboltable(){
        this.head=new Node(null,null,null);
        this.N=0;
    }
    //获取符号表中键值对的个数
    public int size(){
        return N;
    }
    //往符号表中插入键值对
    public void put(Key key,Value value){
        //判断是否有已经存在的键
        Node h=head;
        for(int i=0;i<N;i++){
            h=h.next;
            if(key.equals(h.key)){
                h.value=value;//如果这个键已经存在，就替换他的值
                return;
            }
        }
        //如果没有，插入到头部
        Node n=new Node(key,value,null);
        if(head.next==null){
            head.next=n;
            N++;
        }
        else{
            Node oldfirst=head.next;
            head.next=n;
            n.next=oldfirst;
            N++;
        }
    }
    //删除符号表中键为key的键值对
    public void delete(Key key){
        Node n=head.next;
        Node pre=head;
        if(head.next!=null){
            for(int i=0;i<N;i++){
                if(n.key.equals(key)){
                    Node post=n.next;
                    pre.next=post;
                    N--;
                    return;
                }
                n=n.next;
                pre=pre.next;
            }
        }
    }
    //获取符号表中key对应的值{
    public Value get(Key key){
        Node n=head.next;
        if(n!=null){
            for(int i=0;i<N;i++){
                if(n.key.equals(key)){
                   return n.value;
                }
                n=n.next;

            }
        }
        return null;
    }
}
```
## 3.2 有序符号表
普通符号表插入的时候没有考虑键值的顺序。实际上我们需要对键的大小进行排序，插入的时候需要考虑顺序。
```java
 public void put(Key key,Value value){
        Node pre=head;
        Node curr=head.next;
        while(curr!=null && key.compareTo(curr.key)>0){ //键大于当前元素的键
            pre=curr;
            curr=curr.next;
        }
        if(curr!=null && key.compareTo(curr.key)==0){//键相等
            curr.value=value;
            return;
        }
        pre.next=new Node(key,value,curr);//键小于 或 current为null
        N++;
        }
```
个人感悟：
就插值的时候和普通符号表的代码不一样
# 4.树
## 4.1 树的基本定义
特点：
1.每个结点有0个或者多个子节点
2.没有父节点的节点为根节点
3.每一个非根节点只有一个父节点
4.每个结点及其后代结点整体上可以看成一个树，成为当前结点的父节点的一个子树
## 4.2 树的术语
结点的度：一个结点含有子树的个数（子结点的个数）
叶结点：度为0的结点
分支节点：度不为0的结点
结点的层次：根节点层为1，后继层为2，以此类推
结点的层序编号：从上到下，从左往右
树的度：树中结点的度的最大值
树的高度：树中结点的最大层次
森林：根节点去掉，树就成为了森林
孩子结点：一个结点的直接后继结点
双亲结点（父结点）：一个结点的直接前驱结点
兄弟结点：同一个双亲结点的子结点互为兄弟结点
## 4.3 二叉树
度不超过2的数（每个结点最多两个子节点）
满二叉树：每一层的节点数都达到最大值
完全二叉树：叶结点值出现在最下层和次下层
### 4.3.1 二叉查找树
```java
public class BinaryTree <Key extends Comparable<Key>,Value> {
    //记录根结点
    private Node root;
    //记录树中元素个数
    private int N;
    private class Node{
        //键
        public Key key;
        //值
        public Value value;
        //左结点
        public Node left;
        //右结点
        public Node right;
        public Node(Key key,Value value,Node left,Node right){
            this.key=key;
            this.value=value;
            this.left=left;
            this.right=right;
        }
    }
    public BinaryTree(){
        this.N=0;
        this.root=null; //初始化没有根结点
    }
    //获取树中元素个数
    public int size(){
        return N;
    }
    //向树中添加元素key-value
    public void put(Key key,Value value){
        root=put(root,key,value);

    }
    //向指定的树x中插入结点，并返回添加元素后新的树
    private Node put(Node x,Key key,Value value){
        //如果子树为空
        if(x==null){
            N++;
            return new Node(key,value,null,null);
        }
        //如果子树不为空
        int cmp=key.compareTo(x.key);
        //比较x结点的键的大小
        //如果key大于x结点，继续找右子树
        if(cmp>0){
            x.right=put(x.right,key,value);
        }
        else if(cmp<0){
            //如果小于x结点，找左子树
            x.left=put(x.left,key,value);
        }
        else{
            x.value=value;
        }
        return x;
    }
    //查询树中指定key对应的value
    public Value get(Key key){
        return get(root,key);
    }
    //查询指定树x中，键对应的值
    public Value get(Node x,Key key){
        //树为null
        if(x==null){
            return null;
        }
        int cmp=key.compareTo(x.key);
        //比较x结点的键的大小
        //如果key大于x结点，继续找右子树
        if(cmp>0){
            return get(x.right,key);
        }
        else if(cmp<0){
            //如果小于x结点，找左子树
            return get(x.left,key);
        }
        else{
            return x.value;
        }

    }
    public void delete(Key key){
        delete(root,key);
    }
    public Node delete(Node x,Key key){
        //x树为null
        if(x==null){
            return null;
        }
        //x树不为null
        int cmp=key.compareTo(x.key);
        //比较x结点的键的大小
        //如果key大于x结点，继续找右子树
        if(cmp>0){
            x.right=delete(x.right,key);
        }
        else if(cmp<0){
            //如果小于x结点，找左子树
            x.left=delete(x.left,key);
        }
        else{
            //删除
            N--; //数量减1
            //找到右子树中最小的结点
            if(x.right==null){
                if(x==root){ //删除的是根结点并且根结点没有右子树
                    root=x.left;
                    return root;
                }
                else{
                return x.left;} //删除的结点没有右子树
            }
            if(x.left==null){ //删除的是根结点且没有左子树
                if(x==root) {
                    root=x.right;
                    return root;
                }
                else{
                    return x.right;
                }

            }
            Node min=x.right;
            while(min.left!=null){
                min=min.left; //找到右子树最小结点
            }
            Node n=x.right;
            //删除右子树的最小结点
            while(n.left!=null){
                if(n.left.left==null){ //n为最小结点的上一个
                    n.left=n.left.right; //把下一个结点（最小结点）删除，但是它的右边可能还有结构，如果按照视频里的这个就没了
                    break;
                }
                else{
                    n=n.left;
                }

            }
            //让x结点的左子树成为min的左子树
            min.left=x.left;
            //让x结点的右子树成为min的右子树
            if(min==x.right){
                min.right=x.right.right;//特殊情况，如果没有这个判断，x=x，成环了
            }else{
                min.right=x.right;
            }

            //min成为x父节点的
            if(x==root){
                root=min;
            }
            else{
                x=min;
            }

        }

        return x;

    }

}
个人感悟：
视频中有许多错误，没有考虑特殊情况，需要修改，比如根结点的删除。
```
### 4.3.2 二叉查找树便捷方法
#### 4.3.2.1 查找最小键
```java
public Key min(){
        return min(root).key;
    }
    public Node min(Node x){
        if(x==null){
            return null;
        }
        if(x.left!=null){
            return min(x.left);
        }
        else{
            return x;
        }
    }
```
#### 4.3.2.2 查找最大键
```java
public Key max(){
        return max(root).key;
    }
    public Node max(Node x){
        if(x==null){
            return null;
        }
        if(x.right!=null){
            return max(x.right);
        }
        else{
            return x;
        }
    }
```
### 4.3.3 二叉查找树的基础遍历
#### 4.3.3.1 前序遍历
先根结点，再左子树，后右子树
```java
public Queue<Key> preErgodic(){
        Queue<Key> keys = new Queue<>();//创建队列（先进先出）
        preErgodic(root,keys);
        return keys; //返回队列
    }
    private void preErgodic(Node x,Queue<Key> keys){
        if(x==null){
            return;
        }
        //把x的key放入keys中
        keys.enqueue(x.key);
        //递归遍历左子树
        if(x.left!=null){
        preErgodic(x.left,keys);
        }
        if(x.right!=null){
        //递归遍历右子树
        preErgodic(x.right,keys);
        }
    }
```
#### 4.3.3.2 中序遍历
先左子树，后根结点，再右子树
```java
public Queue<Key> midErgodic(){
        Queue<Key> keys = new Queue<>();//创建队列（先进先出）
        midErgodic(root,keys);
        return keys; //返回队列
    }
    private void midErgodic(Node x,Queue<Key> keys) {
        if(x==null){
            return;
        }
        //递归遍历左子树
        if(x.left!=null){
            midErgodic(x.left,keys);
        }
        //把x的key放入keys中
        keys.enqueue(x.key);
        if(x.right!=null){
            //递归遍历右子树
            midErgodic(x.right,keys);
        }
    }
```
#### 4.3.3.3 后序遍历
先左子树，再右子树，后根结点
```java
public Queue<Key> afterErgodic(){
        Queue<Key> keys = new Queue<>();//创建队列（先进先出）
        afterErgodic(root,keys);
        return keys; //返回队列
    }
    private void afterErgodic(Node x,Queue<Key> keys) {
        if(x==null){
            return;
        }
        //递归遍历左子树
        if(x.left!=null){
            afterErgodic(x.left,keys);
        }
        if(x.right!=null){
            //递归遍历右子树
            afterErgodic(x.right,keys);
        }
        //把x的key放入keys中
        keys.enqueue(x.key);

    }
```

个人感悟：
都是使用递归的思想
### 4.3.4 二叉树的层序遍历
从根结点开始，依次往下，从左往右（广度优先遍历）
1.先创建一个队列，存储每一层结点
2.使用循环从队列中弹出一个结点
	2.1获取当前结点的key；
	2.2如果当前结点的左子节点不为空，则把左子节点放在队列中
	2.3如果当前结点的右子节点不为空，则把右子节点放在队列中
```java
public Queue<Key> layerErgodic(){
        Queue<Key> keys = new Queue<>();//创建队列
        Queue<Node> nodes = new Queue<>();
        //队列中放入根结点
        nodes.enqueue(root);
        while(!nodes.isEmpty()){
            //弹出一个结点
            Node cur=nodes.dequeue();
            keys.enqueue(cur.key);
            //有没有左子节点，放入队列中
            if(cur.left!=null){
                nodes.enqueue(cur.left);
            }
            //有没有右子节点，放入队列中
            if(cur.right!=null){
                nodes.enqueue(cur.right);
            }
        }

        return keys;
    }
```
个人感悟：
太巧妙了！
### 4.3.5 二叉树的最大深度问题
```java
public int maxDepth(){
        return maxDepth(root);
    }
    private int maxDepth(Node x){
        if(x==null){
            return 0;
        }
        int maxleft=0;
        int maxright=0;
        int max=0;
        if(x.left!=null){
            maxleft=maxDepth(x.left);
        }
        if(x.right!=null){
            maxright=maxDepth(x.right);
        }
        if(maxleft>maxright){
            max=maxleft+1;
        }
        else{
            max=maxright+1;
        }
        return max;
    }
```
个人感悟：
递归我要玩哭了
### 4.3.6 折纸问题
```java
public class PagerFoldingTest {
    public static void main(String[] args) {
        //模拟折纸过程
        Node<String> tree=createTree(3);
        printTree(tree);


        //遍历
    }
    public static Node<String> createTree(int n){
        Node<String> root=null;
        for (int i = 0; i < n; i++) {
            //第一次对折
            if(i==0){
                root=new Node<>("down",null,null);
                continue;
            }
            //不是第一次对折 层序遍历
            //辅助队列,找到叶子结点
            Queue<Node> queue = new Queue<>();
            queue.enqueue(root);
            while (!queue.isEmpty()){
                //弹出一个结点
                Node<String> cur=queue.dequeue();
                //如果有左子节点，则把左子节点放入队列中
                if(cur.left!=null){
                    queue.enqueue(cur.left);
                }
                //如果有右子节点，则把右子节点放入队列中
                if(cur.right!=null){
                    queue.enqueue(cur.right);
                }
                if(cur.left==null && cur.right==null){  //层序遍历找到叶子结点
                    cur.left=new Node<String>("down",null,null);
                    cur.right=new Node<String>("up",null,null);
                }
            }
        }
        return root;
    }
    public static void printTree(Node<String> root){
        if(root==null){
            return;
        }
        if(root.left!=null){
            printTree(root.left);
        }
        System.out.println(root.item+" ");
        if(root.right!=null){
           printTree(root.right);
        }
    }

    private static class Node<T>{
        public T item;
        public Node left;
        public Node right;

        public Node(T item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }
}
```
## 4.3平衡树
### 4.3.1 2-3查找树
2-结点：含有一个键（及其对应的值）和两条链
3-结点，含有两个键（及其对应的值）和三条链
性质：
1.任意空链接到根结点的路径长度是相等的
2.4-结点分为3-结点时，树的高度不会变化，只有当根结点是临时4-结点时，树高+1
3.2-3树和普通查找树最大区别在于，普通的二叉查找树是自顶向下增长，而2-3树是自底向上增长
### 4.3.2 红黑树
对2-3树进行编码，用标准的二叉查找树和一些额外信息来表示2-3树
红链接：将两个2-结点连接起来构成一个3-结点
黑链接：2-3树中的普通链接
定义：
1.红链接均为左链接
2.没有任何一个结点同时和两条红链接相连
3.该树是完美黑色平衡的，任意空链接到根结点的路径上的黑链接数量相同
左旋：当某个结点的左子节点为黑色，右子结点是红色，需要左旋
右旋：当某个结点的左子节点是红色，左子节点的左子节点也是红色，需要左旋
颜色反转：当某个结点左右子节点都为红色
```java
public class RedBlackTree<Key extends Comparable<Key>,Value> {
    //根结点
    private Node root;
    //根个数
    private int N;
    //红色链接
    private static final boolean RED=true;
    //黑色链接
    private static final boolean BLACK=false;

    //结点类
    private class Node{
        public Key key;
        public Value value;
        public Node left;
        public Node right;
        //父节点指向它的链接的颜色
        public boolean color;
        public Node(Key key,Value value,Node left,Node right,boolean color){
            this.key=key;
            this.value=value;
            this.left=left;
            this.right=right;
            this.color=color;
        }

    }
    //获取树中元素的geshu
    public int size(){
        return N;
    }
    //判断当前结点的父类指向链接是否为红色
    private boolean isRed(Node x){
        if(x==null){
            return false;
        }
        return x.color==RED;
    }
    //左旋
    private Node roatateLeft(Node h){
        //获取h结点的右子结点，标为x
        Node x=h.right;
        //x的左子节点成为H的右子节点
        h.right=x.left;
        //h成为x的左子节点
        x.left=h;
        //交换color
        x.color=h.color;
        h.color=RED;
        return x;
    }
    //右旋
    private Node roatateRight(Node h){
        //获取h结点的左子结点，标为x
        Node x=h.left;
        //x的右子节点成为H的左子节点
        h.left=x.right;
        //h成为x的右子节点
        x.right=h;
        //交换color
        x.color=h.color;
        h.color=RED;
        return x;
    }
   //颜色反转
    private void flipColors(Node h){
        h.color=RED;
        h.left.color=BLACK;
        h.right.color=BLACK;
    }
    //插入操作
    public void put(Key key,Value value){
        root=put(root,key,value);
        //根结点的颜色总为黑色
        root.color=BLACK;
    }
    private Node put(Node h,Key key,Value value){
        //如何h为空，直接返回一个红色结点
        if(h==null){
            N++;
            return new Node(key,value,null,null,RED);
        }
        //比较h的键和key的大小
        int cmp=key.compareTo(h.key);
        if(cmp<0){
            //继续往左
            h.left=put(h.left,key,value);

        }
        else if(cmp>0){
            h.right=put(h.right,key,value);
        }
        else{
            h.value=value;
        }
        //左旋 右旋 颜色反转
        if(!isRed(h.left) && isRed(h.right)){
            h=roatateLeft(h);
        }
        if(isRed(h.left) && isRed(h.left.left)){
            h=roatateRight(h);
        }
        if(isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }

        return h;
    }
    //根据key找值
    public Value get(Key key){
        return get(root,key);
    }
    public Value get(Node x,Key key){
        if(x==null){
            return null;
        }
        int cmp=key.compareTo(x.key);
        if(cmp<0){
            return get(x.left,key);
        }
        else if(cmp>0){
            return get(x.right,key);
        }
        else{
            return x.value;
        }
    }
}
```
### 4.3.3 B-树
B树允许一个结点包含多个key，参数M，M阶的B树
1.每个结点最多有（M-1）个Key
2.每个结点最多有M个子结点
3.根结点至少有两结点
应用：磁盘
### 4.3.4 B+树
非叶子结点不包含真正的数据
应用：数据库

# 5.堆
堆的特性：
1.完全二叉树，每一层都是满的，
2.用数组来实现,一个结点位置为k,它的父节点为k/2，子节点为2k和2k+1
3.每个结点都大于等于它的两个子节点
```java
public class Heap<T extends Comparable<T>> {
    //存储堆的元素
    private T[] imtes;
    //记录堆中元素的个数
    private int N;
    public Heap(int capacity){
        this.imtes=(T[]) new Comparable[capacity+1];//0索引废弃
        this.N=0;
    }
    //判断堆中索引i是否小于索引j处的元素
    private boolean less(int i,int j){
        return imtes[i].compareTo(imtes[j])<0;
    }
    //交换堆中i索引和j索引处的值
    private void exch(int i,int j){
        T temp=imtes[i];
        imtes[i]=imtes[j];
        imtes[j]=temp;

    }
    //往堆中插入一个元素
    public void insert(T t){
        imtes[++N]=t; //0索引被废弃掉
        swim(N);
    }
    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k){
        while(k>1) {
            if (less(k/2,k)) {
                exch(k,k/2);
                k/=2;
            }
            else{
                break;
            }

        }
    }
    //删除堆中最大的元素，并返回这个最大元素
    public T delMax(){
        T max=imtes[1];
        //交换索引1和N的元素，让最右侧元素作为临时根结点
        exch(1,N);
        //删除最大索引元素
        imtes[N]=null;
        //个数减一
        N--;
        //下沉算法调制
        sink(1);
        return max;
    }
    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    public void sink(int k) {
        //通过循环不断循环当前结点k和其子节点2k 2k+1的大小
        while (2 * k <= N) {//有左子节点{
            int max=0;
            if (2 * k + 1 <= N) {
                if (less(2 * k, 2 * k + 1)) {
                    max = 2 * k + 1;}
                else{
                    max=2*k;
                    }
                }
            else{
                max=2*k;
            }
            if(less(k,max)){
                exch(k,max);
                k=max;
            }
            else{
                break;
            }
            }
        }

}
```
## 5.1 堆排序
1.先把数组中的元素拷贝到堆中，注意堆的0索引处没有元素
2.通过下沉的方法使得堆的结点大于等于它的子节点，使得堆有序
3.在堆中进行排序，把索引1出的元素与未排序的最大索引处进行交换，然后对1索引处的元素下沉
```java
public class HeapSort {
    //判断堆中索引i处的元素是否小于索引j处的元素
    private static boolean less(Comparable[] heap,int i,int j){
        return heap[i].compareTo(heap[j])<0;
    }
    //交换heap中i索引和j索引处的值
    private static void exch(Comparable[] heap,int i, int j){
        Comparable temp=heap[i];
        heap[i]=heap[j];
        heap[j]=temp;
    }
    //对原数组source，构造出堆heap
    private static void createHeap(Comparable[] source,Comparable[] heap){
        //拷贝
        System.arraycopy(source,0,heap,1,source.length);
        //对堆中的元素做下沉，从长度的一半处开始向索引1处扫描，因为叶子结点不能下沉，要找到非叶子结点
        for(int i= heap.length/2;i>=1;i--){
            sink(heap,i, heap.length-1);
        }
    }
    //对source数组中的数据从小到大排序
    public static void sort(Comparable[] source){
        //构建堆
        Comparable[] heap=new Comparable[source.length+1];
        createHeap(source,heap);
        //定义一个变量，记录未排序的最大索引
        int max_index= heap.length-1;
        //通过循环，交换1索引和排序元素中最大索引处的元素
        while(max_index!=1){
            exch(heap,1,max_index);
            sink(heap,1, max_index-1);
            max_index--;
        }
        System.arraycopy(heap,1,source,0,source.length);
    }
    //在heap中，对target处的元素做下沉，范围为0-range
    private static void sink(Comparable[] heap,int target,int range){
        while(2*target<=range){
            //找出当前结点较大的子结点
            int max;
            if(2*target+1<=range){
                max=heap[2*target].compareTo(heap[2*target+1])>0?2*target:2*target+1;
            }
            else{
                max=2*target;
            }
            if(!less(heap,target,max)){
                break;
            }
            else{
                exch(heap,target,max);
            }
            target=max;
        }
    }
}
```
# 6.优先队列
基于堆，普通队列先进先出，优先队列最大值先出或最小值先出
最大优先队列：可以获取并删除队列中的最大值
最小优先队列：可以获取并删除队列中的最小值
## 6.1最大优先队列
```java
public class MaxPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;
    public MaxPriorityQueue(int capacity){
        this.items = (T[])new Comparable[capacity+1];
        this.N=0;
    }
    //获取堆中元素个数
    public int size(){
        return N;
    }
    //判断队列中元素是否为空
    public boolean isEmpty(){
        return N==0;
    }
    //判断堆中索引i是否小于索引j的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }
    //交换
    private void exch(int i,int j){
        T tmp=items[i];
        items[i]=items[j];
        items[j]=tmp;
    }
    //往堆中插入一个元素
    public void insert(T t){
        items[++N]=t;
        swim(N);
    }
    //删除堆中最大的元素，并返回这个元素的最大值
    public T delMax(){
        T max=items[1];
        exch(1,N);
       items[N--]=null;
       sink(1);
        return max;
    }

    //上浮算法
    private void swim(int k){
        while(k>1){
            if(less(k/2,k)){
                exch(k,k/2);
                k/=2;
            }
            else{
                break;
            }
        }
    }
    //下沉suanfa
    private void sink(int k){
        int max;
        while(2*k<=N)//有左子节点
        {
            if (2 * k + 1 <= N) //有右子节点
            {
                if (less(k * 2, 2 * k + 1))
                {
                    max = 2 * k + 1;
                } else
                {
                    max = 2 * k;
                }
            }
            else //没有右子节点
            {
                max = 2 * k;

            }
            if (less(k, max)) {
                exch(k,max);
                k=max;
            }
            else {
                break;
            }

        }
    }
}
```
## 6.2最小优先队列
```java
public class MinPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;
    public MinPriorityQueue(int capacity){
        this.items = (T[])new Comparable[capacity+1];
        this.N=0;
    }
    //获取堆中元素个数
    public int size(){
        return N;
    }
    //判断队列中元素是否为空
    public boolean isEmpty(){
        return N==0;
    }
    //判断堆中索引i是否小于索引j的元素
    private boolean less(int i,int j){
        return items[i].compareTo(items[j])<0;
    }
    //交换
    private void exch(int i,int j){
        T tmp=items[i];
        items[i]=items[j];
        items[j]=tmp;
    }
    //往堆中插入一个元素
    public void insert(T t){
        items[++N]=t;
        swim(N);
    }
    //删除堆中最大的元素，并返回这个元素的最大值
    public T delMin(){
        T min=items[1];
        exch(1,N);
        items[N--]=null;
        sink(1);
        return min;
    }

    //上浮算法
    private void swim(int k){
        while(k>1){
            if(!less(k/2,k)){
                exch(k,k/2);
                k/=2;
            }
            else{
                break;
            }
        }
    }
    //下沉算法
    private void sink(int k){
        int min;
        while(2*k<=N)//有左子节点
        {
            if (2 * k + 1 <= N) //有右子节点
            {
                if (!less(k * 2, 2 * k + 1))
                {
                    min = 2 * k + 1;
                } else
                {
                    min = 2 * k;
                }
            }
            else //没有右子节点
            {
                min = 2 * k;

            }
            if (!less(k, min)) {
                exch(k,min);
                k=min;
            }
            else {
                break;
            }

        }
    }
}
```
个人感悟：
就是最大优先队列倒一下
## 6.3 索引优先队列
一个索引对应一个元素，根据元素大小对索引排序
如果修改，不能破坏原数据键值关系，就把所有键抽出来组成一个队列PQ，修改原数据，只需要对PQ的元素进行下沉和上浮，为了更好找到PQ中的值，逆序出来QP数组，找PQ的值就是找QP的索引。
```java
public class IndexMinPriorityQueue<T extends Comparable<T>> {
    //用来存储元素的数组
    private T[] items;
    //保存每个元素在items数组中的索引，pq数组需要堆有序
    private int[] pq;
    //qp保存pq的逆序，pq的值作为索引，pq的索引作为值
    private int[] qp;
    //记录元素个数
    private int N;
    public IndexMinPriorityQueue(int capacity){
        this.N=0;
        this.items=(T[])new Comparable[capacity+1];
        this.pq=new int[capacity+1]; //存的items的索引
        this.qp=new int[capacity+1];
        //默认情况下，队列中不存任何数据，让qp元素都为1
        for (int i=0;i< qp.length;i++) {
            qp[i]=-1;
        }
    }
    //获取队列中元素的个数
    public int size(){
        return N;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return N==0;
    }
    private boolean less(int i,int j){ //i,j 针对pq数组
        return items[pq[i]].compareTo(items[pq[j]])<0;
    }
    //交换
    private void exch(int i,int j){ //i,j 针对pq数组 原数组不动
        //交换pq中的数据
        int tmp=pq[i];
        pq[i]=pq[j];
        pq[j]=tmp;
        //跟心qp中的数据
        qp[pq[i]]=i;
        qp[pq[i]]=j;
    }
    //判断k对应的元素是否存在
    public boolean contains(int k){
        return qp[k]!=-1;
    }
    //最小元素关联的索引
    public int minIndex(){
        return pq[1];
    }
    //往队列中插入一个元素,并关联索引i
    public void insert(int i,T t){
        //判断索引i是否被关联
        if(contains(i)){
            return;
        }
        //个数加一
        N++;
        //数据存到items对应的i位置处
        items[i]=t;
        //把i存到pq中
        pq[N]=i;
        qp[i]=N;
        //堆上浮
        swim(N);
    }
    //删除最小元素并返回该元素的索引
    public int delMin(){
        int minIndex=pq[1];
        //交换
        exch(1,N);
        qp[pq[N]]=-1;
        pq[N]=-1;
        items[minIndex]=null;
        //个数减一
        N--;
        //下沉
        sink(1);
        return minIndex;
    }
    //删除索引i关联的元素
    public void delete(int i){ //i针对pq
        //找到i在pq中的索引
        int k=qp[i];
        exch(k,N);
        items[pq[N]]=null;
        qp[pq[N]]=-1;
        pq[N]=-1;
        N--;
        sink(k);
        swim(k);
    }
    //修改索引i关联的元素
    public void changeItem(int i,T t){
        items[i]=t;
        int k=qp[i];
        sink(k);
        swim(k);
    }
    private void swim(int k){
        while(k>1){
            if(less(k,k/2)){
                exch(k,k/2);
                k/=2;
            }
            else{
                break;
            }
        }
    }
    private void sink(int k){
        int min;
        while(2*k<=N)//有左子节点
        {
            if (2 * k + 1 <= N) //有右子节点
            {
                if (!less(k * 2, 2 * k + 1))
                {
                    min = 2 * k + 1;
                } else
                {
                    min = 2 * k;
                }
            }
            else //没有右子节点
            {
                min = 2 * k;

            }
            if (!less(k, min)) {
                exch(k,min);
                k=min;
            }
            else {
                break;
            }

        }
    }
}
```


# 7并查集
## 7.1低配并查集
树形结构
1.每个元素对应一个结点
2.每一组数据的多个元素都在同一棵树中
3.一个组的数据对应的树和另外一个组中的数据对应的树之间没有任何联系
4.元素在树中并没有子父级关系的硬性要求
```java
public class UF {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录分组个数
    private int count;
    //初始化查并集
    public UF(int N){
        //初始化分组数量，默认N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup=new int[N];
        //初始化eleAndGroup中元素所在组的标识符,让eleAndGroup数组的索引作为每个节点的元素，每个索引的元素就是索引的值
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }

    }
    //获取当前查并集有多少个分组
    public int count(){
        return count;
    }
    //查询p所在分组的标识符
    public int find(int p){
        return eleAndGroup[p];
    }
    //判断并查集中元素p和元素q是否在一个分组中
    public boolean connected(int p,int q){
        return find(p)==find(q);
    }
    //合并
    public void union(int p,int q){
        if(connected(p,q)){
            return;
        }
        //找到p
        int pGroup=find(p);
        //找到q
        int qGroup=find(q);
        //让p所在组所有元素标识符变为q所在组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            if(eleAndGroup[i]==pGroup){
                eleAndGroup[i]=qGroup;
            }
        }
        count--;
    }
}
```
## 7.2优化版并查集
```java
public class UF_tree {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录分组个数
    private int count;
    //初始化查并集
    public UF_tree(int N){
        //初始化分组数量，默认N个分组
        this.count=N;
        //初始化eleAndGroup数组
        this.eleAndGroup=new int[N];
        //初始化eleAndGroup中元素所在组的标识符,让eleAndGroup数组的索引作为每个节点的元素，每个索引的元素就是索引的值
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i]=i;
        }

    }
    //获取当前查并集有多少个分组
    public int count(){
        return count;
    }
    //查询p所在分组的标识符
    public int find(int p){
       while(true){
           if(p==eleAndGroup[p]){
               return p;
           }
           else{
               p=eleAndGroup[p];
           }
       }
    }
    //判断并查集中元素p和元素q是否在一个分组中
    public boolean connected(int p,int q){
        return find(p)==find(q);
    }
    //合并
    public void union(int p,int q){
       //找到根结点
        int pRoot=find(p);
        int qRoot=find(q);
        if(pRoot==qRoot){
            return;
        }
        //让p所在树的根结点等于q所在树的根结点
        eleAndGroup[pRoot]=qRoot;
        count--;
    }
}
```
## 7.3路径压缩
```java
public class UF_Tree_Weighted {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录分组个数
    private int count;
    //用来存储每一个根结点对应树中保存结点的个数
    private int[] sz;

    //初始化查并集
    public UF_Tree_Weighted(int N) {
        //初始化分组数量，默认N个分组
        this.count = N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        this.sz = new int[N];
        //初始化eleAndGroup中元素所在组的标识符,让eleAndGroup数组的索引作为每个节点的元素，每个索引的元素就是索引的值
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i] = i;
            sz[i] = 1;
        }

    }

    //获取当前查并集有多少个分组
    public int count() {
        return count;
    }

    //查询p所在分组的标识符
    public int find(int p) {
        while (true) {
            if (p == eleAndGroup[p]) {
                return p;
            } else {
                p = eleAndGroup[p];
            }
        }
    }

    //判断并查集中元素p和元素q是否在一个分组中
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    //合并
    public void union(int p, int q) {
        //找到根结点
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            return;
        }
        //让p所在树的根结点等于q所在树的根结点
        if (sz[p] < sz[q]) {
            eleAndGroup[pRoot] = qRoot;
            sz[qRoot]+=sz[pRoot];
        } else {
            eleAndGroup[qRoot] = pRoot;
            sz[pRoot]+=sz[qRoot];
        }
        count--;
    }

}
```
# 8图
图是一组顶点和一组能将两个顶点相连的边组成
图的分类
1.无向图
2.有向图
## 8.1无向图
### 8.1.1图的术语
相邻顶点：当两个顶点通过一条边相连
度：依附该顶点边的个数
子图：一幅图所有边的子集
路径：边顺序连接的一系列顶点
环：至少含有一条边，且起点和终点相同的路径
连通图：图中任意一个顶点都存在一条路径到达另外一个顶点
连通子图：一个非连通图由若干连通部分组成，每一个连通的部分都是可以称为该图的连通子图
### 8.1.2图的存储结构
#### 8.1.2.1邻接矩阵
用二维矩阵表示图
空间复杂度是n^2
#### 8.1.2.2邻接表
1.使用一个大小为V的数组，把索引看做顶点
2.每个索引处有一个队列，存储与该顶点相邻的顶点
```java
public class Graph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;
    public Graph(int V) {
        this.V = V;
        this.E = 0;
        this.adj = new Queue[V];//存储顶点的队列，每个点也有一个对应的队列，队里里套队列。
        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }
    }
    //获取顶点数目
    public int V(){
        return V;
    }
    //获取边数目
    public int E(){
        return E;
    }
    //向图中添加一条边v-w;
    public void addEdge(int v,int w){
        adj[v].enqueue(w);
        adj[w].enqueue(v);
        E++;
    }
    //获取和顶点v相邻的所有顶点
    public Queue<Integer> adj(int i){
        return adj[i];
    }
}
```
## 8.2图的搜索
### 8.2.1深度优先搜索
先找子结点，再找兄弟结点
```java
public class DepthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录多少顶点与s顶点想通
    private int count;
    public DepthFirstSearch(Graph G,int s){
        this.marked=new boolean[G.V()]; //有多少个顶点，这个数组就多长
        this.count=0;
        dfs(G,s);
    }
    //使用深度优先搜素找出G图中V顶点的所有相邻顶点
    private void dfs(Graph G,int v){
        marked[v]=true;
        for (Integer w : G.adj(v)) { //获取v对应队列里的元素（与v相邻的结点）
            if(!marked[w]){
                dfs(G,w);
            }
        }
        count++;
    }
    //判断w顶点与s顶点是否想通
    public boolean marked(int w){
        return marked[w];
    }
    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return count;
    }

}
```
### 8.2.2广度优先搜索
```java
public class BreadthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录多少顶点与s顶点想通
    private int count;
    private Queue<Integer> waitSearch;
    public BreadthFirstSearch(Graph G,int s){
        this.marked=new boolean[G.V()];
        this.count=0;
        waitSearch=new Queue<Integer>();//辅助队列
        bfs(G,s);
    }
    //使用深度优先搜素找出G图中V顶点的所有相邻顶点
    private void bfs(Graph G,int v){
        marked[v]=true;
        //v进入队列,待搜索
        waitSearch.enqueue(v);
        //通过循环，如果队列不为空，弹出元素，
        while(!waitSearch.isEmpty()){
            Integer wait=waitSearch.dequeue();
            for(Integer w: G.adj(wait)){
                if(!marked(w)){
                    marked[w]=true;
                    waitSearch.enqueue(w);
                    count++;
                }
            }
        }
        count++;
    }
    //判断w顶点与s顶点是否想通
    public boolean marked(int w){
        return marked[w];
    }
    //获取与顶点s相通的所有顶点的总数
    public int count(){
        return count;
    }
}
```
## 8.3 路径查找
```java
public class DepthFirstPaths {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //起点
    private int s;
    //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点
    private int[] edgeTo;
    //构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路程
    public DepthFirstPaths(Graph G,int s){
        this.s=s;
        this.marked=new boolean[G.V()];
        this.edgeTo=new int[G.V()];
        dfs(G,s);
    }
    //使用深度优先搜索找出G图中v顶点的所有相邻顶点
    private void dfs(Graph G,int v){
       marked[v]=true;
        for (Integer w : G.adj(v)) {
            if(!marked[w]){
                edgeTo[w]=v; //到达顶点w的路径最后以顶点是v
                dfs(G,w);
            }
        }
    }
    //判断w顶点与s顶点是否存在路径
    public boolean hasPathTo(int v){
        return marked[v];
    }
    //找出从起点s到顶点v的路径
    public Stack<Integer> pathTo(int v){
        if(!hasPathTo(v)){
            return null;
        }
        Stack<Integer> path = new Stack<>();
        int cur;
        cur=v;
        while(cur!=s){
            path.push(cur);
            cur=edgeTo[cur];
        }
        path.push(s);
        return path;

    }
}
```
# 8.4有向图
### 8.4.1有向图的术语
定义：有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成，每条方向的边都连着一对有序的顶点
出度：某个顶点指出的边的个数称为该顶点的出度
入度：指向某顶点边的个数称为该顶点的入度
有向路径：由一系列顶点组成，对于其中的顶点都存在一条有向边，从它指向序列中的下一个顶点
有向环：一条至少含有一条边，且起点和终点相同的有向路径
```java
public class Digraph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;
    public Digraph(int V){
        this.V=V;
        this.E=0;
        this.adj=new Queue[V];
         for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }
    }
    //获取顶点数目
    public int V(){
        return V;
    }
    //获取边的数目
    public int E(){
        return E;
    }
    //向有向图中添加一条边v->w
    public void addEdge(int v,int w){
        adj[v].enqueue(w);
        E++;
    }
    //获取由v指出的边所连接的所有顶点
    public Queue<Integer> adj(int v){
        return adj[v];
    }
    //该图的反向图
    private Digraph reverse(){
        Digraph r = new Digraph(V);
        for(int i=0;i<V;i++){
            for (Integer w : adj[i]) {
                r.addEdge(w,i);
            }
        }
        return r;
        
    }
}
```
# 8.5拓扑排序
### 8.5.1检测图中有环
```java
public class DirectedCycle {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录图中是否有环
    private boolean hasCycle;
    //索引代表顶点，使用栈的思想，记录当前顶点有没有处于正在搜索的有向路径上
    private boolean[] onStack;
    private DirectedCycle(Digraph G){
        this.marked=new boolean[G.V()];
        this.hasCycle=false;
        this.onStack=new boolean[G.V()];
        for(int v=0;v< G.V();v++){
            if(!marked[v]){
            dfs(G,v);
            }
        }
    }
    //基于深度优先搜索，检测是否有环
    private void dfs(Digraph G,int v){
        //表示已经搜索过
        marked[v]=true;
        onStack[v]=true;
        for (Integer w : G.adj(v)) {
            if(!marked[w]){
                dfs(G,w);
            }
            //判断是否已经在栈中
            if(onStack[w]){
                hasCycle=true;
                return;
            }
        }
        onStack[v]=false;

    }

    public boolean hasCycle(){
        return hasCycle;
    }
}
```
### 8.5.2顶点排序
```java
public class DepthFirstOrder {
    //索引代表顶点，值代表该顶点是否已被搜索
    private boolean[] marked;
    //使用栈，存储顶点序列
    private Stack<Integer> reversePost;
    //创建一个检测环对象，检测图中是否有环
    public DepthFirstOrder(Digraph G){
        marked=new boolean[G.V()];
        this.reversePost=new Stack<Integer>();
        for (int i = 0; i < G.V(); i++) {
            if(!marked[i]){
                dfs(G,i);
            }
        }
    }
    //基于深度优先搜索，检测图中是否有环
    private void dfs(Digraph G,int v){
        marked[v]=true;
        //通过循环深度搜索顶点v
        for (Integer w : G.adj(v)) {
            if(!marked[w]){
                dfs(G,w);
            }
        }
          reversePost.push(v);
    }
    //获取顶点线性序列
    public Stack<Integer> reversePost(){
        return reversePost;
    }
}
```
### 8.5.3拓扑排序
```java
public class TopoLogical {
    //顶点的拓扑排序
    private Stack<Integer> order;
    //构造拓扑排序对象
    public TopoLogical(Digraph G){
        //创建检测有向环的对象
        DirectedCycle cycle=new DirectedCycle(G);
        if(!cycle.hasCycle()){
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G);
            order=depthFirstOrder.reversePost();
        }
    }
    //判断图里是否有环
    private boolean isCycle(){
        return order==null;
    }
    //获取拓扑排序的所有顶点
    public Stack<Integer> order(){
        return order;
    }
}
```
## 8.6加权无向图
路径加全职来代表距离或者时间
加权边：
```java
public class Edge implements Comparable<Edge>{
    private final int v;//顶点一
    private final int w;//顶点二
    private final double weight;//当前边的权重
    //通过顶点v和w，以及权重weight值构造一个边对象
    public Edge(int v,int w,double weight){
        this.v=v;
        this.w=w;
        this.weight=weight;
    }
    
    //获取边的权重值
    public double weight(){
        return weight;
    }
    //获取边行的一个点
    public int either(){
        return v;
    }
    //获取边上的除了顶点vertex外的另一个顶点
    public int other(int vertex){
        if(vertex==v){
            return w;
        }
        else {
            return v;
        }
    }

    @Override
    public int compareTo(Edge that) {
        int cmp;
        //如果当前边的权重值大，则让cmp=1
        if(this.weight()>that.weight()){
            cmp=1;
        }
        //如果当前边的权重值小，则让cmp=-1
        else if(this.weight()<that.weight()){
            cmp=-1;
        }
        //如果当前边的权重值一样大，则让cmp=0
        else{
            cmp=0;
        }
        return cmp;
    }
}
```
```java
public class EdgeWeightedGraph {
    //顶点个数
    private final int V;
    //边个数
    private int E;
    //邻接表
    private Queue<Edge>[] adj;
    //创建一个还有v个顶点的空加权无向图
    public EdgeWeightedGraph(int v){
        this.V=v;
        this.E=0;
        this.adj=new Queue[V]; //声明长度为V，元素类型为队列的数组
        for (int i = 0; i < adj.length; i++) {
            adj[i]=new Queue<Edge>();//数组的每个元素初始化为队列，队列里的元素类型为edge
        }
    }
    //获取图中顶点数量
    public int V(){
        return V;
    }
    //获取图中边的数量
    public int E(){
        return E;
    }
    //向加权无向图中添加一条边
    public void addEdge(Edge e){
        //边e同时出现在两个顶点的邻接表中
        int v=e.either();
        int w=e.other(v);
        adj[v].enqueue(e);
        adj[w].enqueue(e);
        E++;
    }
    //获取和顶点v关联的所有边
    public Queue<Edge> adj(int v){
        return adj[v];
    }
    //获取加权无向图的所有边
    public Queue<Edge> edges(){
        //创建一个队列对象，存储所有边
        Queue<Edge> allEdges=new Queue<>();
        //遍历每一个顶点
        for(int v=0;v<V;v++){
            //遍历v的邻接表
            for (Edge e : adj[v]) {
                if(e.other(v)<v){ //为了只添加一次
                    allEdges.enqueue(e);
                }
            }
        }
        return allEdges;
    }
}
```
## 8.7最小生成树
### 8.7.1树的性质
1.用一条边接树中的任意两个顶点都会产生一个新的环
2.从树中删除任意一条边，将会得到两棵独立的树
### 8.7.2切分定理
切分：将图的所有顶点按照某些规则分为两个非空且没有交集的集合
横切边：连接两个属于不同集合的顶点的边称为横切边
切分定理：在一副加权图中，给定任意的切分，它的横切边的权重最小必然属于图中的最小生成树
### 8.7.3贪心算法
使用切分定理找到最小生成树的一条边，不断重复找到最小生成树的所有边
### 8.7.4 Prim算法
切分规则：
把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做另外一个集合
```java
public class PrimMST {
    //索引代表顶点，值代表当前顶点和最小生成树的最短边
    private Edge[] edgeTo;
    //索引代表顶点，值表示当前顶点和最小生成树之间最短边的权重
    private double[] disTo;
    //索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false
    private boolean[] marked;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq; //这个是干嘛的啊
    //根据一副加权无向图，创建最小生成树
    public PrimMST(EdgeWeightedGraph G){
        this.edgeTo=new Edge[G.V()];
        this.disTo=new double[G.V()];
        for (int i = 0; i < disTo.length; i++) {
            disTo[i]=Double.POSITIVE_INFINITY;
        }
        this.marked=new boolean[G.V()];
        pq=new IndexMinPriorityQueue<Double>(G.V());
        //默认让顶点0进入树中,树中只有顶点0，没有与其他任何点相连
        disTo[0]=0.0;
        pq.insert(0,0.0);
        //遍历索引最小优先队列，拿到最小横切边对应的顶点，把该顶点加入到最小生成树中
        while(!pq.isEmpty()){
            visit(G,pq.delMin());
        }
    }
    //将顶点v添加到最小生成树中，并且更新数据
    private void visit(EdgeWeightedGraph G,int v){
        marked[v]=true;
        for (Edge e : G.adj(v)) {
            int w=e.other(v);
            if(marked[w]){
                continue;
            }
            //判断e的权重是否小于w顶点到树中已经存在的最小边的权重
            if(e.weight()<disTo[w])
                edgeTo[w]=e;
                disTo[w]=e.weight();
                if(pq.contains(w)){
                    pq.changeItem(w, e.weight());
                }
                else{
                    pq.insert(w, e.weight());
                }
        }
    }
    public Queue<Edge> edges(){
        Queue<Edge> allEdges = new Queue<Edge>();
        for (int i = 0; i < allEdges.size(); i++) {
            if(edgeTo[i]!=null){
                allEdges.enqueue(edgeTo[i]);
            }
        }
        return allEdges;
    }
}
```
### 8.7.5 Kruskal算法
```java
public class Kruskal {
    //保存最小生成树的所有边
    private Queue<Edge> mst;
    //索引代表顶点，使用uf.connect(v,w)判断v,w是否在一棵树中，使用uf.union（v,w）进行合并
    private UF_Tree_Weighted uf;
    //存储图中所有的边，使用最小优先队列，对边的权重进行排序
    private MinPriorityQueue<Edge> pq;
    
    public Kruskal(EdgeWeightedGraph G){
        this.mst=new Queue<Edge>();
        this.uf=new UF_Tree_Weighted(G.V());
        this.pq=new MinPriorityQueue<>(G.E());
        for (Edge e : G.edges()) {
            pq.insert(e);
        }
        //遍历pq，拿到权重最小的边
        while(!pq.isEmpty() && mst.size()<G.V()-1){
            Edge edge=pq.delMin();
            int v=edge.either();
            int w=edge.other(v);
            if(uf.connected(v,w)){
               continue;
            }
            uf.union(v,w);
            mst.enqueue(edge);
            }
        }
        public Queue<Edge> edges(){
        return mst;
        }
        
    }
```
## 8.6加权有向图
### 8.6.1加权有向边
```java
public class DirectedEdge {
    private final int v;//起点
    private final int w;//终点
    private final double weight;//当前边的权重
    //构造边对象
    public DirectedEdge(int v,int w,double weight){
        this.v=v;
        this.w=w;
        this.weight=weight;
    }
    //获取边的权重值
    public double weight(){
        return weight;
    }
    //获取有向边起点
    public int from(){
        return v;
    }
    //获取有向边的终点
    public int to(){
        return w;
    }
}
```
### 8.6.2加权有向图
```java
public class EdgeWeightedDigraph {
    //顶点数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue<DirectedEdge>[] adj;
    //创建一个还有V个顶点的空加权有向图
    public EdgeWeightedDigraph(int V){
        this.V=V;
        this.E=0;
        this.adj=new Queue[V];
        for (int i = 0; i < adj.length; i++) {
            adj[i]=new Queue<DirectedEdge>();
        }
    }
    public int V(){
        return V;
    }
    public int E(){
        return E;
    }
    //添加一条边
    public void addEdge(DirectedEdge e){
        int v=e.from();
        adj[v].enqueue(e);
        E++;
    }
    //获取由顶点v指出的所有的边
    public Queue<DirectedEdge> adj(int v){
        return adj[v];
    }
    //获取所有边
    public Queue<DirectedEdge> edges(){
        Queue<DirectedEdge> allEdges = new Queue<DirectedEdge>();
        for (int i = 0; i < adj.length; i++) {
            for (DirectedEdge e : allEdges) {
                adj[i].enqueue(e);
            }
        }
        return allEdges;
    }
}
```
## 8.7最短路径
```java
public class DijkstraSP {
    //索引代表顶点，值表示顶点s到当前顶点的最短路径上的最后一条边
    private DirectedEdge[] edgeTo;
    //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重
    private double[] disTo;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq;
    //根据一副加权有向图G和顶点s，创建一个顶点为s的最短路径对象
    public DijkstraSP(EdgeWeightedDigraph G,int s){
        this.edgeTo=new DirectedEdge[G.V()];
        this.disTo=new double[G.V()];
        for (int i = 0; i < disTo.length; i++) {
            disTo[i]=Double.POSITIVE_INFINITY;
        }
        this.pq=new IndexMinPriorityQueue<>(G.V());
        //默认让s进入最短路径树中
        disTo[s]=0.0;
        pq.insert(s,0.0);
        while(!pq.isEmpty()){
            relax(G,pq.delMin())；
        }
    }
    //松弛图中G的顶点v
    private void relax(EdgeWeightedDigraph G,int v){
        for (DirectedEdge edge : G.adj(v)) {
            //获取到改边的终点w
            int w=edge.to();
            //判断起点s到顶点w的路径是否需要先从s到顶点v，再从v到w
            if(disTo[v]+edge.weight()<disTo[w]){
                disTo[w]=disTo[v]+edge.weight();
                edgeTo[w]=edge;
                //判断pq中是否已经存在w，如果存在，更新权重，如果不存在，直接添加
                if(pq.contains(w)){
                    pq.changeItem(w,disTo[w]);
                }
                else{
                    pq.insert(w,disTo[w]);
                }
                
            }
        }
    }
    //获取从顶点s到顶点v的最短边的总权重
    public double distTo(int v){
        return disTo[v];
    }
    //是否可达
    public boolean hasPathTo(int v){
        return disTo[v]<Double.POSITIVE_INFINITY;
    }
    //查询从起点s到顶点v的最短路径的所有边
    public Queue<DirectedEdge> pathTo(int v){
        if(!hasPathTo(v)){
            return null;
        }
        Queue<DirectedEdge> allEdges = new Queue<DirectedEdge>();
        while(true){
            DirectedEdge e=edgeTo[v];
            if(e==null){
                break;
            }
            allEdges.enqueue(e);
            v=e.from();
        }
        return allEdges;
        
    }
}
```














